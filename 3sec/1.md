### 型
PHPは8つの型の動的型付け言語。  
・整数  
・浮動小数点  
・文字列  
・論理  
・配列  
・リソース  
・オブジェクト  
・null  

#### 整数  
10進数、16進数(0x*)、8進数(0*)で指定可能。先頭に[+]、[-]をつける事も可。  
最大値を超えた整数は自動的に浮動小数点数(float)へキャストされる。  
phpは符号なし整数(unsigned int)をサポートしてない。  
```
<?php
$int1 = 1;
$int2 = -1;
$int3 = 011;
$int4 = 0xff;
$int5 = PHP_INT_MAX;
$int6 = PHP_INT_MAX+1;
var_dump($int1,$int2,$int3,$int4,$int5,$int6);
```
実行結果  
```
int(1)  
int(-1)  
int(9)  
int(255)  
int(9223372036854775807)  
float(9.2233720368548E+18)  
```

#### 浮動小数点数
小数点を含む実数、指定表記で初期化で指定可能
少数や分数のように整数で表す事出来ない、実数。  
phpの浮動小数点はfloatと表記されてるが、実際には **倍精度浮動小数点(double)** である。  

```
<?php
$float1 = 1.2; //実数
$float2 = 1.2e3; //指数部を指定
```

#### 文字列
phpにおいて文字列はとても重要な役割を果たす。  
正規表現リテラルが存在しないため、正規表現を用いた処理を行う場合、正規表現を表す文字列を指定。  
phpは**すべて可変長文字列**  

#### ヒアドキュメント
```
<?php
$age = 22;
$foo = <<<EOI
うわああああもう
こんな歳だあああ
{$age}歳
拳で
EOI;
var_dump($foo);
```
実行結果  
```
string(62) "うわああああもう
こんな歳だあああ
22歳
拳で"
```
#### Newdoc(php5.3<=)
ヒアドキュメント構文に続く終端識別子をシングルクォートで囲むことで指定可能。  
**変数の展開がされない**ヒアドキュメントのようなもの。  
クラス定義のプロパティ定義やconst定義など式を記述できない場所に使用可。  
```
<?php
$age = 22;
$foo = <<<'EOI'
うわああああもう
こんな歳だあああ
{$age}歳
拳で
EOI;
var_dump($foo);
```
実行結果  
```
string(66) "うわああああもう
こんな歳だあああ
{$age}歳
拳で"
```


#### 文字列型とキャスト
echoなどで出力を行う場合、文字列意外の変数、定数など**実際すべて文字列にキャストされてから出力**されている。  
例)  
```
//文字列型へキャストされ整数と判断され".0"が省略
echo 15.0; // 15

//明示的に小数点以下を出力したい場合
printf('%.1f',15.0); //15.0
```

#### 論理型
真偽値。phpでは**論理型の大文字と小文字**は区別されない。  
何かの値があるものはほとんどがtrue扱い。  
以下7つfalse判定  
・false(論理型)  
・0(整数型)  
・0.0(浮動小数点型)  
・空の文字列("")、文字列の0  
・要素の数が0の配列  
・null  
・空のタグから作成されたSimpleXMLオブジェクト  


#### 配列
添字配列、連想配列区別されずどちらも配列  

#### オブジェクト
クラスをnew演算子によりインスタンス化したモノへの参照。  

#### リソース
オープンされたファイルやデータベース接続など、何らかの外部リソースへの参照を保持した型。  
多くの外部リソースを扱う拡張機能がバンドルされているため、多くのリソース型とその初期化関数が存在してる。  

get_resource_type()関数でリソース型の種類を確認できる。


リソース|拡張機能|初期化関数|補足
-|- |-|-
sockets file |sockets |socket_create()|ソケットリソース
curl | curl|curl_init()|curlリソース
mysql link|mysql|mysql_connect()|mysqlサーバへの接続リソース
stream|標準など|fopen()とか|プロトコルラッパー



#### null
定数が値を持たない型。  
・定数nullが代入されている場合  
・値が何も代入されていない場合  
・unset()されている場合  
```
<?php
function no_return_func(){
}
$null_value = no_return_func();
```
**nullの代入された変数とunset()により解除された変数は本質的には等価**
しかしunset()で解除した変数を参照したときのErrorはNoticeが発生するのに対し、nullの代入された変数は定義されているものとして扱われる  


#### 自動キャスト
以下2点で発生  
・異なる型同士で演算を行う場面  
・演算子、制御構造、関数やメソッドが特定の型の引数を必要としてる状態で異なる型を渡した場合  

**phpは二項演算を行う際、2つの項のどちらも「数値らしき文字列」の場合、「整数型または浮動小数点型へキャストする」という性質がある。**  
```
<?php
if('0.0' == '0') {
    echo '"0.0"と"0"は等しいです。'
}
```
1 '0.0'は数値っぽいので0.0浮動小数点型へキャスト  
2 '0'が数値っぽいので0整数型へキャスト  
3 浮動小数点0.0と整数0の比較で、整数0は浮動小数点0.0へキャスト  
4 比較し、結果真  

以下の文字列は**数値らしい文字列**なので自動キャストされた場合は、数値へキャスト  
・10進数を表した文字列('10','-10.0','10.0e-1','0123'など)  
・16進数を表した文字列('0x10'など)  

**結果、以下の危険性**  
ユーザ登録を行うアプリケーションのパスワード入力画面で「パスワード入力」と「確認の入力」  
の2つの項目に入力をし、その2つが一致していなければ登録できないような処理  
```
//2つのパスワード比較
if($passwd1 == $passwd2) {
    echo "正"
}
```
**「0123」==「123」は真になってしまう**

### 演算子
演算とは、値(正確には式)に対して何がしらの別の値を生み出すために行われる操作  
単項演算子 二項演算子 三項演算子の3つ  

#### 代行演算子
```
echo $a = 10; // 10
```

#### 代数演算子
四則演算師と剰余をする演算子合わせて5つ  
・加算(+)  
・減算(-)  
・積(*)  
・商(/)  
・剰余(%)  

#### ビット演算子
```
<?php
printf("%032b\n",15);
printf("%032b\n",51);
printf("%032b\n",15&51); // AND
printf("%032b\n",15|51); // OR
printf("%032b\n",15^51); // XOR
printf("%032b\n",~15);   // NOT
printf("%032b\n",15<<1); // 左シフト
printf("%032b\n",15>>1); // 右シフト
```
実行結果  
```
00000000000000000000000000001111
00000000000000000000000000110011
00000000000000000000000000000011
00000000000000000000000000111111
00000000000000000000000000111100
11111111111111111111111111110000
00000000000000000000000000011110
00000000000000000000000000000111
```

#### 文字列演算子
連結のドット(.)はスペースあけろ、浮動小数点型として自動キャストされる可能性ある。  
```
<?php
$a = "歳"
echo 22. $a; //22.0の浮動小数点型とみなされ、parseerror
echo 22 . $a; //OK
```

#### 型演算子(instanceof)
右辺が特定のクラスのインスタンスである場合に真となります。  
```
<?php
class SomeClass {}
$a = new SomeClass();
if($a instanceof SomeClass) {
    echo '$a はSomeClassのインスタンスです。',PHP_EOL;
}
```

・特定のクラスを継承したクラスのインスタンスか  
・特定のインターフェイスを実装したクラスのインスタンスか  
```
<?php
interface FooInterface{}
class ParentFoo{}
class Foo extends ParentFoo implements FooInterface{}
class Hoge extends ParentFoo implements FooInterface{ function test(){}}
class Bar{}
$a = new Foo();
var_dump($a instanceof Foo);          //true
var_dump($a instanceof ParentFoo);    //true
var_dump($a instanceof FooInterface); //true
var_dump($a instanceof Hoge);         //false
var_dump($a instanceof Bar);          //false
```


#### 三項演算子
省略記法  
```
<?php
function some_func(){return 10;}
echo $result = some_func()?:'default';
```

phpの三項演算子は**左結合**です。  
左から評価されます。  
```
<?php
$flag1 = true;
$flag2 = false;
echo $flag1 ? 1:$flag2?2:0; //2
```

#### エラー制御演算子
エラー制御演算子(@)は、式で発生するエラーを制御  
@をつけることにより、noticeが制御。しかし**思わぬバグを仕込む原因の1つ**
えむ得ない状況でない限り使わない。  
```
<?php
$var = @$_GET['foo'];
```

#### 実行演算子
バッククオートで囲まれた部分がシェルのコマンド実行  
shell_exec()と等価
```
<?php
echo $res = `ls`;
```


### 配列
変数に **ブラケット([])** でアクセス
```
<?php
$a = ['apple','banana','orange'];
var_dump($a[1]);
```
#### 連想配列
キーに用いることができるのは、  
・整数  
・文字列  
に加えて  
・論理型(true=>1,false=>0)  
・浮動小数点型(整数に丸められる)  
・null(空文字)  

**array_key_existsよりissetな**
```
<?php
$ar = ['hoge'=>1,'fuga'=>2];
array_key_exists('hoge',$ar);
isset($ar['hoge']); //issetのほうが速い
```
**array_key_existsは値がnullでもkeyがあればtrue**  
**issetはkeyあっても値がnullならfalse**
